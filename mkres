#!/usr/bin/env python3.7
"""\
mkres - Make research

Copyright (C) 2019 Espen Andersen

This program comes with ABSOLUTELY NO WARRANTY.
This is free software, and you are welcome to redistribute it
under certain conditions."""

import argparse
import ast
import inspect
import linecache
import matplotlib.pylab
import matplotlib.pyplot
import numpy
import os
import pandas
import re
import seaborn
import shutil
import sys
import tempfile
import textwrap
import unicodecsv as csv
import uuid
import mysql.connector

from collections import defaultdict
from latex import build_pdf
from string import Template

__version__ = '0.0.1'
__license__ = 'GPL v3'

class MkresErrorExit( Exception ):

    pass

class LicenseWriter( argparse.Action ):

    def __init__( self, option_strings, dest, nargs = None, **kwargs ):

        self.__license_text = r'''

Utility for generating PDF research reports from MySQL scripts.
Copyright (C) 2019  Espen Andersen <post@espenandersen.no>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
'''
        super( LicenseWriter, self ).__init__( option_strings, dest, nargs = 0, **kwargs )

    def __call__( self, parser, namespace, values, option_string = None ):
        print( self.__license_text )
        parser.exit()

def print_exception():

    exc_type, exc_obj, tb = sys.exc_info()
    f = tb.tb_frame
    lineno = tb.tb_lineno
    filename = f.f_code.co_filename
    linecache.checkcache( filename )
    line = linecache.getline( filename, lineno, f.f_globals )

    print( 'Exception in ({}, ln {} "{}"): {}'.format( filename, lineno, line.strip(), exc_obj ) )

def mkfilename( str ):

    valid = frozenset( '-_.() abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' )
    return ''.join( c for c in str if c in valid )

def get_argparser():

    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=__doc__+'''\n\nType `mkres -c\' for details.''' )

    parser.register( 'action', 'license', LicenseWriter )

    parser.add_argument( '-c',
                         '--copyright',
                         action='license',
                         help='display license info' )

    parser.add_argument( '-o',
                         '--output',
                         help='file name of output PDF' )

    parser.add_argument( '-t',
                         '--tex',
                         action='store_true',
                         help='ouput LaTeX source repo' )

    parser.add_argument( '-v',
                         '--version',
                         action='version',
                         version="%(prog)s (" + __version__ + ")",
                         help="display version info")

    parser.add_argument( 'INPUT',
                         help='file name of input PDF' )

    return parser

def parse_parameters( str ):

    config = str.split( '\n' )
    config = map( lambda s: re.compile( r'\s+' ).sub( s.strip().replace( '  ', ' ' ), ' ' ), config )
    config = list( filter( lambda s: s != '', config ) )
    return { k.strip() : v.strip().strip( '"' ) for k, v in ( param.split( '=' ) for param in config ) }

def parse_part( part ):

    statements = re.sub( r'\/\*.*?\*\/', '', part, 0, re.MULTILINE | re.DOTALL )
    statements = statements.replace( '\n', ' ' ).replace( '\r', ' ' ).split( ';' )

    statements = map( lambda s: re.sub( r'\s+', ' ', s.strip().replace( '  ', ' ' ), 0 ), statements )
    statements = list( filter( lambda s: s != '', statements ) )

    m = re.search( r'<CONFIG>([^<]+)</CONFIG>', part, re.MULTILINE )
    config = parse_parameters( str( m.groups( 1 )[ 0 ] ) ) if m is not None else None

    m = re.search( r'<LATEX>([^<]+)</LATEX>', part, re.MULTILINE )
    latex = m.groups( 1 )[ 0 ] if m is not None else ''

    m = re.search( r'<COLS>([^<]+)</COLS>', part, re.MULTILINE )
    cols = m.groups( 1 )[ 0 ] if m is not None else None

    m = re.search( r'<SEABORN>([^<]+)</SEABORN>', part, re.MULTILINE )
    seaborn = parse_parameters( str( m.groups( 1 )[ 0 ] ) ) if m is not None else None

    m = re.search( r'<WORDCLOUD>([^<]+)</WORDCLOUD>', part, re.MULTILINE )
    wordcloud = m.groups( 1 )[ 0 ] if m is not None else None

    m = re.search( r'\\section\{([^\}]+)\}', latex, re.MULTILINE )
    section = m.groups( 1 )[ 0 ] if m is not None else None

    m = re.search( r'\\subsection\{([^\}]+)\}', latex, re.MULTILINE )
    subsection = m.groups( 1 )[ 0 ] if m is not None else None

    m = re.search( r'\\subsubsection\{([^\}]+)\}', latex, re.MULTILINE )
    subsubsection = m.groups( 1 )[ 0 ] if m is not None else None

    if config is not None:
        config[ 'tempdir' ] = tempfile.mkdtemp()
        parse_part._config = config

    return {
        'config': parse_part._config if hasattr( parse_part, '_config' ) else None,
        'statements': statements,
        'section': section,
        'subsection': subsection,
        'subsubsection': subsubsection,
        'latex': latex,
        'cols': cols,
        'seaborn': seaborn,
        'wordcloud': wordcloud }

def parse_file( filename ):

    delimiter = '/**'
    parts = []

    cnx, cur = None, None

    with open( filename, 'r', encoding='UTF-8' ) as inputfile:

        try:
            input = [ delimiter + chunk for chunk in inputfile.read().split( delimiter ) if chunk ]
        except UnicodeDecodeError as err:
            print( "    Input file must be UTF-8 enoded." )
            raise

    for i, rawpart in enumerate( input ):

        part = parse_part( rawpart )
        config = part[ 'config' ]

        if part[ 'config' ] is None:
            raise MkresErrorExit( f'Input file error\nMissing or malformed <CONFIG> element in the source file\'s header.' )

        try:

            cnx = mysql.connector.connect(
                user = config[ 'user' ],
                password = config[ 'password' ],
                host = config[ 'host' ],
                port = config[ 'port' ],
                database = config[ 'database' ] )

        except mysql.connector.errors.InterfaceError as err:

            raise MkresErrorExit( f'Connection error\n{err}' ) from err

        except KeyError as err:

            raise MkresErrorExit( f'Malformed connection parameter\nConfiguration parameter {err} not found.' ) from err

        cur = cnx.cursor( buffered = True )

        if part[ 'section' ] is not None:
            print( '\33[1m\33[37m%s\33[0m' % part[ 'section' ] )

        if part[ 'subsection' ] is not None:
            print( '\33[37m -- %s\33[0m' % part[ 'subsection' ] )

        if part[ 'subsubsection' ] is not None:
            print( '\33[37m ---- %s\33[0m' % part[ 'subsubsection' ] )

        for j, statement in enumerate( part[ 'statements' ] ):

            print( f'\033[93m      SQL: ({i+j}) {textwrap.shorten( statement, width=75, placeholder="..." )}', end='\r' )

            cur.execute( statement )

            print( ' ' * 100, end='\r' )

            if cur.rowcount == 0: continue

            hdr = [ i[ 0 ] for i in cur.description ]
            res = cur.fetchall()
            part[ 'datafile' ] = os.path.join( config[ 'tempdir' ], 'mkresdata_%04d.csv' % i )

            with open( part[ 'datafile' ], 'wb' ) as datafile:
                wrt = csv.writer( datafile, delimiter = '\t', lineterminator = '\n' )
                wrt.writerow( hdr )
                wrt.writerows( res )

        parts.append( part )

        if cur is not None: cur.close()
        if cnx is not None: cnx.close()

    return parts

def build_table( part ):

    relative_path = os.path.relpath( part[ 'datafile' ], part[ 'config' ][ 'tempdir' ] )
    return ( r'''\pgfplotstabletypeset[begin table={\begin{tabularx}{\textwidth}{%(cols)s}}]'''
             r'''{%(datafile)s}\FloatBarrier\bigskip''' ) % { 'cols': part[ 'cols' ], 'datafile': relative_path }

def match_args( func, config ):

    possible_args = inspect.signature( func ).parameters
    actual_args = {}
    for arg in possible_args:
        if arg in config:
            actual_args[ arg ] = config[ arg ]

    return actual_args

def as_bool( config, key, default = 'false' ):

    return True if ( config[ key ].lower() if key in config else default.lower() ) == 'true' else False

def as_tuple( str ):

    m = re.compile( '\(\s*([0-9]+)\s*,\s*([0-9]+)\s*\)' ).match( str )
    return ( int( m.groups( 1 ) ), int( m.groups( 2 ) ) ) if m is not None else None

def configure_axes( gfxconfig, axes ):

    axes.set(
        xbound = (
            int( gfxconfig[ 'bound_lower_x' ] ) if 'bound_lower_x' in gfxconfig else None,
            int( gfxconfig[ 'bound_upper_x' ] ) if 'bound_upper_x' in gfxconfig else None ),
        ybound = (
            int( gfxconfig[ 'bound_lower_y' ] ) if 'bound_lower_y' in gfxconfig else None,
            int( gfxconfig[ 'bound_upper_y' ] ) if 'bound_upper_y' in gfxconfig else None ) )

    axes.set(
        xlabel = gfxconfig[ 'label_x' ] if 'label_x' in gfxconfig else '',
        ylabel = gfxconfig[ 'label_y' ] if 'label_y' in gfxconfig else '' )

    if 'legend' in gfxconfig and gfxconfig[ 'legend' ] != False:
        frameon = as_bool( gfxconfig, 'frameon' )
        axes.legend( ncol = 10, loc = 'lower right', frameon = frameon )

    xaxis = axes.get_xaxis()
    yaxis = axes.get_yaxis()

    if 'max_n_locator_x' in gfxconfig:
        xaxis.set_major_locator( matplotlib.pyplot.MaxNLocator( int( gfxconfig[ 'max_n_locator_x' ] ) ) )

    if 'max_n_locator_y' in gfxconfig:
        yaxis.set_major_locator( matplotlib.pyplot.MaxNLocator( int( gfxconfig[ 'max_n_locator_y' ] ) ) )

    if 'use_scientific_x' in gfxconfig:
        xaxis.get_major_formatter().set_scientific( as_bool( gfxconfig, 'use_scientific_x' ) )
    else:
        xaxis.get_major_formatter().set_scientific( False )

    if 'use_scientific_y' in gfxconfig:
        yaxis.get_major_formatter().set_scientific( as_bool( gfxconfig, 'use_scientific_y' ) )
    else:
        yaxis.get_major_formatter().set_scientific( False )

    if 'thousand_separator_x' in gfxconfig:
        sep = gfxconfig[ 'thousand_separator_x' ]
        xaxis.set_major_formatter( matplotlib.ticker.FuncFormatter( lambda x, p: '{:,}'.format( int( x ) ).replace( ',', sep ) ) )

    if 'thousand_separator_y' in gfxconfig:
        sep = gfxconfig[ 'thousand_separator_y' ]
        yaxis.set_major_formatter( matplotlib.ticker.FuncFormatter( lambda x, p: '{:,}'.format( int( x ) ).replace( ',', sep ) ) )

    if 'ticks_positions_x' in gfxconfig:
        ticks = ast.literal_eval( gfxconfig[ 'ticks_positions_x' ] )
        labels = ast.literal_eval( gfxconfig[ 'ticks_labels_x' ] ) if 'ticks_labels_x' in gfxconfig else [ ]
        matplotlib.pyplot.xticks( ticks, labels )

    if 'ticks_positions_y' in gfxconfig:
        ticks = ast.literal_eval( gfxconfig[ 'ticks_positions_y' ] )
        labels = ast.literal_eval( gfxconfig[ 'ticks_labels_y' ] ) if 'ticks_labels_y' in gfxconfig else [ ]
        matplotlib.pyplot.yticks( ticks, labels )

def get_figsize( gfxconfig ):
    return ( int( gfxconfig[ 'width' ] ) if 'width' in gfxconfig else 10,
             int( gfxconfig[ 'height' ] ) if 'height' in gfxconfig else 7 )

def init_graphics_context( part, plot_type ):

    gfxconfig = part[ 'seaborn' ]

    args = match_args( matplotlib.pyplot.subplots, gfxconfig )
    args[ 'figsize' ] = get_figsize( gfxconfig )

    figure, axes = matplotlib.pyplot.subplots( **args )

    if 'subplots_adjust_top' in gfxconfig:
        figure.subplots_adjust( top = float( gfxconfig[ 'subplots_adjust_top' ] ) )
    else:
        figure.subplots_adjust( top = 0.9 )

    if 'subplots_adjust_right' in gfxconfig:
        figure.subplots_adjust( right = float( gfxconfig[ 'subplots_adjust_right' ] ) )
    else:
        figure.subplots_adjust( right = 0.9 )

    if 'subplots_adjust_bottom' in gfxconfig:
        figure.subplots_adjust( bottom = float( gfxconfig[ 'subplots_adjust_bottom' ] ) )
    else:
        figure.subplots_adjust( bottom = 0.15 )

    if 'subplots_adjust_left' in gfxconfig:
        figure.subplots_adjust( left = float( gfxconfig[ 'subplots_adjust_left' ] ) )
    else:
        figure.subplots_adjust( left = 0.15 )

    args = match_args( plot_type, gfxconfig )
    args[ 'label' ] = gfxconfig[ 'label' ] if 'label' in gfxconfig else ''

    plot = plot_type( **args )

    configure_axes( gfxconfig, axes )

    if 'ticks_labelsize' in gfxconfig:
        plot.tick_params( labelsize = int( gfxconfig[ 'ticks_labelsize' ] ) )

    if as_bool( gfxconfig, 'despine', 'true' ):
        seaborn.despine( left = True, bottom = True )

    for l in axes.lines:
        matplotlib.pylab.setp( l, linewidth = 5.0 )

    return figure, axes

def build_graphics_barplot( part ):

    return init_graphics_context( part, seaborn.barplot )

def build_graphics_lineplot( part ):

    return init_graphics_context( part, seaborn.lineplot )

def build_graphics_scatterplot( part ):

    return init_graphics_context( part, seaborn.scatterplot )

def build_graphics( part ):

    print( f'\033[93m    SEABORN: Building {part[ "seaborn" ][ "chart_type" ]} {part[ "seaborn" ][ "id" ]}', end='\r' )

    gfxconfig = part[ 'seaborn' ]
    gfxconfig[ 'data' ] = pandas.read_csv( part[ 'datafile' ], sep = '\t', dtype = None, encoding = 'utf-8' )

    chart_type = gfxconfig[ 'chart_type' ] if 'chart_type' in gfxconfig else 'barplot'

    seaborn.set( style = gfxconfig['style'] if 'style' in gfxconfig else 'whitegrid' )
    seaborn.set_color_codes( gfxconfig['color_codes'] if 'color_codes' in gfxconfig else 'pastel' )

    plot = None

    if 'legend' not in gfxconfig or gfxconfig[ 'legend' ].lower() == 'false':
        gfxconfig[ 'legend' ] = False

    try:
        # One of build_graphics_barplot / build_graphics_scatterplot / build_graphics_lineplot methods
        globals()[ 'build_graphics_%s' % chart_type ] ( part )

    except KeyError as err:
        raise AttributeError( 'Wrong or missing attribute for chart type \'%s\'' % chart_type ) from err

    if 'id' not in gfxconfig:
        gfxconfig[ 'id' ] = str( uuid.uuid4() )

    if 'outputfile' not in gfxconfig:
        gfxconfig[ 'outputfile' ] = os.path.join( part[ 'config' ][ 'tempdir' ], '%s.png' % gfxconfig[ 'id' ] )

    resolution = int( gfxconfig[ 'dpi' ] ) if 'dpi' in gfxconfig else 400
    matplotlib.pyplot.savefig( gfxconfig[ 'outputfile' ], dpi = resolution )

    print( ' ' * 100, end='\r' )

    return gfxconfig[ 'outputfile' ]


def build_latex_body( parts ):

    body = ''

    for part in parts:
        body += r'''
\setlength{\parskip}{\baselineskip}%(latex)s\medskip
\FloatBarrier''' % part

        if part[ 'cols' ] is not None:
            body += build_table( part )

        if part[ 'seaborn' ] is not None:
            build_graphics( part )

        body += r'''
\bigskip'''

    for part in parts:

        if part[ 'seaborn' ] is None: continue

        relative_path = os.path.relpath( part[ 'seaborn' ][ 'outputfile' ], part[ 'config' ][ 'tempdir' ] )
        pat = '(.*)(path-to:%s)([^a-z_].*)'  % part[ 'seaborn' ][ 'id' ]
        body = re.compile( pat, re.MULTILINE | re.DOTALL | re.IGNORECASE ).sub( '\\1%s\\3' % relative_path, body )

    return body

def build_latex( parts ):

    config = parts[ 0 ][ 'config' ]
    config[ 'texmain' ] = os.path.join( config[ 'tempdir' ], 'main.tex' )
    config[ 'texbody' ] = os.path.join( config[ 'tempdir' ], 'body.tex' )

    try:
        wrapper = r'''\documentclass[9pt,a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{makeidx}
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage{parskip}
\usepackage{kpfonts}
\usepackage[left=2.5cm,right=2.5cm,top=2.5cm,bottom=3cm]{geometry}
\usepackage{pgfplotstable}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{array}
\usepackage{colortbl}
\usepackage{placeins}
\usepackage[%(language)s]{babel}
\renewcommand{\arraystretch}{1.2}
\pgfplotsset{compat=1.13}
\pgfplotstableset {
    column type=,
    end table={\end{tabularx}},
    col sep=tab,
    string type,
    every head row/.style={after row=\hline\rule{0pt}{4.5mm}},
    every head row/.append style={
      typeset cell/.code={
    \ifnum\pgfplotstablecol=\pgfplotstablecols
                  \pgfkeyssetvalue{/pgfplots/table/@cell content}{\textbf{##1}\\\\}
              \else
                  \pgfkeyssetvalue{/pgfplots/table/@cell content}{\textbf{##1}&}
              \fi
          }
  },
    every last row/.style={after row=\hline\rule{0pt}{4.5mm}}
}
\title{%(document_title)s}
\author{%(document_author)s}
\begin{document}
    \maketitle
    \newpage
    \tableofcontents
    \newpage
    \begin{flushleft}
    \input{body.tex}
    \end{flushleft}
\end{document}''' % config

    except KeyError as e:

        print( 'Configuration parameter %s is missing from the input file' % e )
        sys.exit( 1 )

    with open( config[ 'texmain' ], 'w', encoding='utf-8' ) as input:
        input.write( wrapper )

    with open( config[ 'texbody' ], 'w', encoding='utf-8' ) as input:
        input.write( build_latex_body( parts ) )

    return config[ 'texmain' ]

def export_tex_repository( config ):

    attempt = 0
    config[ 'export_name' ] = config[ 'output_name' ]

    while os.path.isdir( config[ 'export_name' ] ):

        attempt = attempt + 1
        config[ 'export_name' ] = '%s_%02d' % ( config[ 'output_name' ], attempt )

        if attempt == 99:

            msg_fmt = ( 'Gave up after %d attempts to create directory '
                        'for LaTeX export (a directory named %s already exists)' )

            errdesc = msg_fmt % ( attempt + 1, config[ 'export_name' ] )

            raise SystemError( errdesc )

    print( f'\33[37m    LaTeX source exported to {config[ "export_name" ]}\33[0m' )

    shutil.copytree( config[ 'tempdir' ], config[ 'export_name' ] )

    print( ' ' * 100, end='\r' )

def main():

    os.system( 'setterm -cursor off' )
    print( "" )

    result = 'FAILED'

    try:

        argparser = get_argparser()
        args = argparser.parse_args()

        parts = parse_file( args.INPUT )
        config = parts[ 0 ][ 'config' ]

        of = mkfilename(
            config[ 'outputfile' ] ) if 'outputfile' in config else os.path.basename( args.INPUT )

        config[ 'output_name' ] = os.path.splitext( of )[ 0 ]

        print( "" )

        texfile = build_latex( parts )

        print( f'\033[93m    PDFLATEX: Building PDF file {config[ "output_name" ] + ".pdf"}', end='\r' )

        with open( texfile ) as tex_fp:
            pdf = build_pdf( tex_fp, texinputs = [ config[ 'tempdir' ] ] )

        pdf.save_to( config[ 'output_name' ] + '.pdf' )

        print( ' ' * 100, end='\r' )

        if args.tex == True:
            export_tex_repository( config )

        result = 'SUCCESS!'

    except MkresErrorExit as err:

        msg = '\n    \33[91m'.join( str( err ).split( '\n' ) )
        print( f'\n\33[1m\33[37m    {msg}\33[0m' )

    finally:
        print( f'\n\33[1m\33[37m    {result}\33[0m' )
        os.system( 'setterm -cursor on' ) # Restore visible cursor
        print( '\033[m' ) # Restore native color


if __name__ == '__main__':
    main()
